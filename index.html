    <script>
        // --- Configuration ---
        // ... (keep existing captchaWords, interpretations) ...

        // --- Helper Functions ---
        // ... (keep existing helpers: getRandomElement, showLoading, hideLoading) ...

        // --- NEW: Canvas Drawing Function ---
        function drawCaptcha(text) {
            const canvas = document.getElementById('captcha-canvas');
            const hiddenMessageSpan = document.getElementById('captcha-message-hidden'); // Get hidden span
            if (!canvas || !canvas.getContext) {
                console.error("Canvas not supported or not found!");
                 // Fallback: display text in hidden span if canvas fails
                 if(hiddenMessageSpan) hiddenMessageSpan.textContent = text;
                return;
            }
             // Store the text semantically for interpretation later
             if(hiddenMessageSpan) hiddenMessageSpan.textContent = text;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.fillStyle = '#f9f9f9'; // Light background
            ctx.fillRect(0, 0, width, height);

            // Basic styling
            ctx.font = 'bold 38px "Courier New", monospace'; // Larger, bolder font
            ctx.fillStyle = '#333';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Add some noise lines
            for (let i = 0; i < 5; i++) {
                ctx.strokeStyle = `rgba(${Math.random()*150}, ${Math.random()*150}, ${Math.random()*150}, 0.3)`; // Darker noise
                ctx.beginPath();
                ctx.moveTo(Math.random() * width, Math.random() * height);
                ctx.lineTo(Math.random() * width, Math.random() * height);
                ctx.lineWidth = Math.random() * 2 + 1;
                ctx.stroke();
            }

            // Draw text with slight distortion
            const words = text.split(' ');
            const startX = width / (words.length + 1);

            words.forEach((word, index) => {
                ctx.save();
                // Apply slight rotation and vertical shift per word
                const angle = (Math.random() - 0.5) * 0.2; // Radians (approx +/- 6 degrees)
                const yOffset = (Math.random() - 0.5) * 8;
                const xPos = startX * (index + 1);

                ctx.translate(xPos, height / 2 + yOffset);
                ctx.rotate(angle);
                ctx.fillText(word, 0, 0);
                ctx.restore();
            });

             // Add some noise dots
            for (let i = 0; i < 100; i++) {
                ctx.fillStyle = `rgba(${Math.random()*150}, ${Math.random()*150}, ${Math.random()*150}, 0.2)`;
                ctx.beginPath();
                ctx.arc(Math.random() * width, Math.random() * height, Math.random() * 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- DOM Elements ---
        // const captchaMessage = document.getElementById('captcha-message'); // NO LONGER USED directly for display
        const captchaCanvas = document.getElementById('captcha-canvas'); // Get Canvas
        const captchaMessageHidden = document.getElementById('captcha-message-hidden'); // Get hidden span
        // ... (keep other DOM elements) ...

        // --- CAPTCHA Message Functionality ---
        function generateNewCaptcha() {
            const newWord = getRandomElement(captchaWords);
            const secondWord = getRandomElement(captchaWords);
            const captchaText = `${newWord} ${secondWord}`;
            // Draw on canvas AND update hidden span
            drawCaptcha(captchaText);
            interpretationDiv.innerHTML = '<p><em>Awaiting interpretation...</em></p>';
        }

        function interpretCurrentCaptcha() {
            // Read the text from the HIDDEN SPAN, not the canvas
            const currentCaptcha = captchaMessageHidden.textContent;
            if (!currentCaptcha || currentCaptcha.trim() === '' || currentCaptcha === 'awaiting command') { // Add check for initial state if needed
                interpretationDiv.innerHTML = '<p style="color: var(--accent);">You must first summon a message from the Dark Lords.</p>';
                return;
            }

            showLoading(interpretCaptchaBtn);
            // ... (rest of interpretation logic remains the same, reading from currentCaptcha) ...
            setTimeout(() => {
                const interpretation = getRandomElement(interpretations);
                interpretationDiv.innerHTML = `
                    <p><strong>The Dark Lord commands (via ${currentCaptcha}):</strong></p>
                    <p style="color: var(--secondary); font-style: italic;">"${interpretation}"</p>
                `;

                if (messageHistory.querySelector('.no-history')) {
                    messageHistory.innerHTML = '';
                }

                const historyEntry = document.createElement('div');
                historyEntry.style.marginBottom = '1rem';
                // Display the text, not the canvas, in history
                historyEntry.innerHTML = `
                    <p style="margin-bottom: 0.3rem;"><strong>CAPTCHA:</strong> <span class="captcha-text" style="font-size: 1rem; padding: 0.2rem 0.5rem; background: #ddd; border: 1px solid #bbb;">${currentCaptcha}</span></p>
                    <p style="margin-top: 0;"><strong>Meaning:</strong> ${interpretation}</p>
                    <hr style="border-color: var(--button-bg);">
                `;
                messageHistory.prepend(historyEntry);
                messageHistory.scrollTop = 0;

                hideLoading(interpretCaptchaBtn);
            }, 500);
        }

        // ... (keep event listeners for generate/interpret buttons) ...

        // --- Comic Builder Functionality ---
        // ... (keep existing comic builder logic) ...

        // --- Download Comic Placeholder ---
        // ... (keep existing download logic) ...

        // --- Smooth Scrolling ---
        // ... (keep existing scroll logic) ...

        // --- Initial Setup ---
        window.addEventListener('load', () => {
            generateNewCaptcha(); // Generate initial CAPTCHA on load (will draw on canvas)
            updateComicPanels();
        });
    </script>
